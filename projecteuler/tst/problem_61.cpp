/*
 * problem_61.cpp
 *
 *  Created on: Oct 27, 2011
 *      Author: yinterry

 Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

 Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
 Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
 Pentagonal	 	P5,n=n(3n1)/2	 	1, 5, 12, 22, 35, ...
 Hexagonal	 	P6,n=n(2n1)	 	1, 6, 15, 28, 45, ...
 Heptagonal	 	P7,n=n(5n3)/2	 	1, 7, 18, 34, 55, ...
 Octagonal	 	P8,n=n(3n2)	 	1, 8, 21, 40, 65, ...
 The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

 The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
 Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
 This is the only set of 4-digit numbers with this property.
 Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

 */
int Triangle(int n)
{
	return n * (n + 1) / 2;
}

int Square(int n)
{
	return n * n;
}
int Pentagonal(int n)
{
	return n * (3 * n - 1) / 2;
}
int Hexagonal(int n)
{
	return n * (2 * n - 1);
}
int Heptagonal(int n)
{
	return n * (5 * n - 3) / 2;
}
int Octagonal(int n)
{
	return n * (3 * n - 2);
}

#include "CppUTest/TestHarness.h"
#include "CppUTestExt/MockSupport.h"
#include "prime.h"
#include "project_euler.h"

class Polygonals
{
public:
	Polygonals()
	{
		typedef int(*polyfunc)(int);
		polyfunc polys[] =
				{ Triangle, Square, Pentagonal, Hexagonal, Heptagonal,
						Octagonal, NULL };
		for (int i = 0; i < MAX; i++)
		{
			numbers[i].is = false;
			numbers[i].flag = 0;
		}
		for (int j = 0; polys[j] != NULL; j++)
		{
			polyfunc p = polys[j];
			for (int i = 1; p(i) < MAX; i++)
			{
				numbers[p(i)].is = true;
				numbers[p(i)].flag |= (1 << j);
			}
		}
	}
	bool GetConnectedSet(int count, int *output)
	{
		for (int i = 10; i < 100; i++)
			if (getNextConnetedSet(count, i, i, count, output))
				return true;
		return false;
	}
	bool isPoly(int n)
	{
		return numbers[n].is;
	}
	int getFlag(int n){
		return numbers[n].flag;
	}
	bool checkFlags(int count, int *set){
		return _checkFlags(count, set, (1 << count) - 1);
	}
private:
	bool _checkFlags(int count, int *set, int flags){
		for(int i = 1; i <= (1 << 5); i<<=1){
			if ((flags & i) && (numbers[*set].flag & i)){
				if (count == 1)
					return flags == i;
				if (_checkFlags(count-1, set+1, flags & (~i)))
					return true;
			}
		}
		return false;
	}
	bool getNextConnetedSet(int count, int start_with, int last_end, int orignal_count,
			int *output)
	{
		if (count == 1) {
			*output = start_with * 100 + last_end;
			return isPoly(*output) && checkFlags(orignal_count, output - orignal_count + 1);
		}
		for (int j = start_with * 100+10; j < (start_with + 1) * 100; j++)
		{
			if (j %100 != last_end && numbers[j].is)
			{
				output[0] = j;
				if (getNextConnetedSet(count - 1, output[0] % 100, last_end, orignal_count,
						output + 1))
					return true;
			}
		}
		return false;
	}
	enum
	{
		MAX = 10000
	};
	struct
	{
		bool is;
		char flag;
	} numbers[MAX];
};

TEST_GROUP(problem61)
{

};

TEST(problem61, funs)
{
	LONGS_EQUAL(1,Triangle(1));//	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
	LONGS_EQUAL(10,Triangle(4));//	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
	LONGS_EQUAL(16,Square(4));//	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
	LONGS_EQUAL(22,Pentagonal(4));//	 	P5,n=n(3n1)/2	 	1, 5, 12, 22, 35, ...
	LONGS_EQUAL(28,Hexagonal(4));//	 	P6,n=n(2n1)	 	1, 6, 15, 28, 45, ...
	LONGS_EQUAL(34,Heptagonal(4));//	 	P7,n=n(5n3)/2	 	1, 7, 18, 34, 55, ...
	LONGS_EQUAL(40,Octagonal(4));//	 	P8,n=n(3n2)	 	1, 8, 21, 40, 65, ...
}
TEST(problem61, polygonals)
{
	Polygonals poly;
	CHECK(poly.isPoly(10));
	CHECK(poly.isPoly(8128));
	CHECK(poly.isPoly(2882));
	CHECK(!poly.isPoly(8129));
	CHECK_EQUAL(1, poly.getFlag(8128) & 1);
	CHECK_EQUAL(4, poly.getFlag(2882) & 4);
	int set0[] = {8128};
	CHECK(poly.checkFlags(1, set0));
	int set2[] = {8281};
	CHECK(!poly.checkFlags(1, set2));
	int set[] = {8128, 2882, 8281};
	CHECK(poly.checkFlags(3, set));
	int set1[] = {1128,2812,2116,1651,5192,9211};
	CHECK(!poly.checkFlags(6, set1));
}
int get_flags(int *set, int count){
	Polygonals poly;
	int flag = 0;
	for (int i = 0; i < count; i++)
		flag |= poly.getFlag(set[i]);return flag;
}
TEST(problem61, get_one_connected)
{
	Polygonals poly;
	int set[10] =
	{ 0 };
	CHECK(poly.GetConnectedSet(1, set));
	CHECK(poly.isPoly(set[0]));
	CHECK(set[0]%100 == set[0]/100);
	LONGS_EQUAL(1, get_flags(set, 1) & 1);
}

TEST(problem61, get_2_connected)
{
	Polygonals poly;
	int set[10] =
	{ 0 };
	poly.GetConnectedSet(2, set);
	CHECK(poly.isPoly(set[0]));
	CHECK(poly.isPoly(set[1]));
	CHECK(set[0]%100 == set[1]/100);
	CHECK(set[0]/100 == set[1]%100);
	LONGS_EQUAL(3, get_flags(set, 2) & 3);
}
TEST(problem61, get_3_connected)
{
	Polygonals poly;
	int set[10] =
	{ 0 };
	CHECK(poly.GetConnectedSet(3, set));
	CHECK(poly.isPoly(set[0]));
	CHECK(poly.isPoly(set[1]));
}
TEST(problem61, get_4_connected)
{
	Polygonals poly;
	int set[10] =
	{ 0 };
	bool result = poly.GetConnectedSet(4, set);
	CHECK(result);
	CHECK(poly.isPoly(set[0]));
	CHECK(poly.isPoly(set[1]));
	CHECK(set[0]%100 == set[1]/100);
	CHECK(set[0]/100 == set[3]%100);
	LONGS_EQUAL(15, get_flags(set, 4) & 15);
}
TEST(problem61, get_6_connected)
{
	Polygonals poly;
	int set[10] =
	{ 0 };
	CHECK(poly.GetConnectedSet(6, set));
	CHECK(poly.isPoly(set[0]));
	CHECK(poly.isPoly(set[1]));
	CHECK(set[0]%100 == set[1]/100);
	CHECK(set[0]/100 == set[5]%100);
	int flag = 0;
	for (int i = 0; i < 6; i++)
		flag |= poly.getFlag(set[i]);
	LONGS_EQUAL(63, flag);
	int sum = 0;
	for (int i = 0; i < 6; i++)
		sum +=set[i];
	LONGS_EQUAL(28684, sum);
}
